
// OSS Software Solutions Application Programmer Interface
// Package: SBC
// Author: Joegen E. Baclor - mailto:joegen@ossapp.com
//
// Package: SBC
//
// Copyright (c) OSS Software Solutions
//
// Permission is hereby granted, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, execute, and to prepare
// derivative works of the Software, all subject to the
// "OSS Software Solutions OSS API General License Agreement".
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//



#include "OSS/SIP/SBC/SBCRedisConfig.h"
#include "OSS/Persistent/ClassType.h"
#include "OSS/Persistent/DataType.h"
#include "OSS/UTL/Logger.h"
#include <fstream>


namespace OSS {
namespace SIP {
namespace SBC {
  
  
using OSS::Persistent::ClassType;
using OSS::Persistent::DataType;


SBCRedisConfig::SBCRedisConfig(const std::string& componentName, const boost::filesystem::path& configFile) :
  _configFile(configFile),
  _componentName(componentName)
{
  ClassType config;
  if (config.load(_configFile))
  {
    std::string host;
    int port = 0;
    std::string password;

    DataType root = config.self();
    if (root.exists("user-agent"))
    {
      try
      {
        DataType userAgent = root["user-agent"];
        if (userAgent.exists("redis-database"))
        {
          DataType dbs = userAgent["redis-database"];
          int dbCount = dbs.getElementCount();
          for (int i = 0; i < dbCount; i++)
          {
            DataType dbInfo = dbs[i];

            if (dbInfo.exists("host") && dbInfo.exists("port") && dbInfo.exists("password"))
            {
              host = (const char*)dbInfo["host"];
              port = (int)dbInfo["port"];
              password = (const char*)dbInfo["password"];
              addHost(host, port, password);
            }
          }
        }
      }
      catch(const std::exception& e)
      {
        OSS_LOG_ERROR("[REDIS] " << _componentName << "::SBCRedisConfig::connect()  Unable to add workspace " <<  " - " << host << ":" << port << " Exception: " << e.what());
      }
      catch(...)
      {
        OSS_LOG_ERROR("[REDIS] " << _componentName << "::SBCRedisConfig::connect()  Unable to add workspace " << " - " << host << ":" << port << " Exception: UNKNOWN");
      }
    }
  }
}

SBCRedisConfig::SBCRedisConfig(const std::string& componentName) :
  _componentName(componentName)
{
}

SBCRedisConfig::~SBCRedisConfig()
{
}

void SBCRedisConfig::addHost(const std::string host, int port, const std::string& password)
{
  HostEntry entry;
  entry.host = host; 
  entry.port = port;
  entry.password = password;
  _hosts.push_back(entry);
}

bool SBCRedisConfig::connect(Persistent::RedisBroadcastClient& redis, int workspace, bool allowMultiple)
{
  bool connected = false;
  for (HostEntries::iterator iter = _hosts.begin(); iter != _hosts.end(); iter++)
  {
    if (!redis.connect(iter->host, iter->port, iter->password, workspace))
    {
      OSS_LOG_ERROR("[REDIS] " << _componentName << "::SBCRedisConfig::connect()  Unable to add workspace " << workspace << " - " << iter->host << ":" << iter->port);
    }
    else
    {
      OSS_LOG_INFO("[REDIS] " << _componentName << "::SBCRedisConfig::connect() - Added workspace " << workspace << "  - " << iter->host << ":" << iter->port);
      connected = true;
      if (!allowMultiple)
      {
        break;
      }
    }
  }       
  return connected;
}

bool SBCRedisConfig::connect(Persistent::RedisClient& redis, int workspace)
{
  if (_hosts.empty())
  {
    return false;
  }
  HostEntry& host = _hosts.front();
  return redis.connect(host.host, host.port, host.password, workspace);
}

bool SBCRedisConfig::dumpConnectionInfoToFile(const boost::filesystem::path& infoFile)
{
  if (_hosts.empty())
  {
    return false;
  }
  
  std::string dest = OSS::boost_path(infoFile);
  std::ofstream destFile(dest.c_str());
  destFile << "# Auto generated by SBCRedisConfig.  Do not edit this file!" << std::endl;
  destFile << "REDIS_HOST=" << "\"" << _hosts.front().host << "\"" << std::endl;
  destFile << "REDIS_PORT=" << "\"" << _hosts.front().port << "\"" << std::endl;
  destFile << "REDIS_PASS=" << "\"" << _hosts.front().password << "\"" << std::endl;

  return true;
}

bool SBCRedisConfig::dumpConnectionInfoToFile()
{
  boost::filesystem::path infoFile("/tmp/redis-connect-info");
  return dumpConnectionInfoToFile(infoFile);
}

  
} } } // OSS::SIP::SBC


