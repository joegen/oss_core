
// OSS Software Solutions Application Programmer Interface
// Package: SBC
// Author: Joegen E. Baclor - mailto:joegen@ossapp.com
//
// Package: SBC
//
// Copyright (c) OSS Software Solutions
//
// Permission is hereby granted, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, execute, and to prepare
// derivative works of the Software, all subject to the
// "OSS Software Solutions OSS API General License Agreement".
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//



#include "OSS/SIP/SBC/SBCWorkSpaceConfig.h"
#include "OSS/Persistent/ClassType.h"
#include "OSS/Persistent/DataType.h"
#include "OSS/UTL/Logger.h"
#include <fstream>


namespace OSS {
namespace SIP {
namespace SBC {
  
  
using OSS::Persistent::ClassType;
using OSS::Persistent::DataType;


SBCWorkSpaceConfig::SBCWorkSpaceConfig(const std::string& componentName, const boost::filesystem::path& configFile) :
  _configFile(configFile),
  _componentName(componentName),
  _enableRemoteDb(false)
{
  if (_enableRemoteDb)
  {
    ClassType config;
    if (config.load(_configFile))
    {
      std::string host;
      int port = 0;
      std::string password;

      DataType root = config.self();
      if (root.exists("user-agent"))
      {
        try
        {
          DataType userAgent = root["user-agent"];
          if (userAgent.exists("redis-database"))
          {
            DataType dbs = userAgent["redis-database"];
            bool enabled = (bool)dbs["enaled"];
            if (enabled)
            {
              int dbCount = dbs.getElementCount();
              for (int i = 0; i < dbCount; i++)
              {
                DataType dbInfo = dbs[i];

                if (dbInfo.exists("host") && dbInfo.exists("port") && dbInfo.exists("password"))
                {
                  host = (const char*)dbInfo["host"];
                  port = (int)dbInfo["port"];
                  password = (const char*)dbInfo["password"];
                  addHost(host, port, password);
                }
              }
            }
          }
        }
        catch(const std::exception& e)
        {
          OSS_LOG_ERROR("[REDIS] " << _componentName << "::SBCWorkSpaceConfig::connect()  Unable to add workspace " <<  " - " << host << ":" << port << " Exception: " << e.what());
        }
        catch(...)
        {
          OSS_LOG_ERROR("[REDIS] " << _componentName << "::SBCWorkSpaceConfig::connect()  Unable to add workspace " << " - " << host << ":" << port << " Exception: UNKNOWN");
        }
      }
    }
  }
}

SBCWorkSpaceConfig::SBCWorkSpaceConfig(const std::string& componentName) :
  _componentName(componentName)
{
}

SBCWorkSpaceConfig::~SBCWorkSpaceConfig()
{
}

void SBCWorkSpaceConfig::addHost(const std::string host, int port, const std::string& password)
{
  HostEntry entry;
  entry.host = host; 
  entry.port = port;
  entry.password = password;
  _hosts.push_back(entry);
}

bool SBCWorkSpaceConfig::connect(SBCWorkSpace& redis, int workspace, bool allowMultiple)
{
  if (!_enableRemoteDb)
  {
    return false;
  }

  bool connected = false;
  for (HostEntries::iterator iter = _hosts.begin(); iter != _hosts.end(); iter++)
  {
    if (!redis.connect(iter->host, iter->port, iter->password, workspace))
    {
      OSS_LOG_ERROR("[REDIS] " << _componentName << "::SBCWorkSpaceConfig::connect()  Unable to add workspace " << workspace << " - " << iter->host << ":" << iter->port);
    }
    else
    {
      OSS_LOG_INFO("[REDIS] " << _componentName << "::SBCWorkSpaceConfig::connect() - Added workspace " << workspace << "  - " << iter->host << ":" << iter->port);
      connected = true;
      if (!allowMultiple)
      {
        break;
      }
    }
  }       
  return connected;
}

bool SBCWorkSpaceConfig::connect(Persistent::RedisClient& redis, int workspace)
{
  return false;
  if (!_enableRemoteDb)
  {
    return false;
  }
  HostEntry& host = _hosts.front();
  return redis.connect(host.host, host.port, host.password, workspace);
}

bool SBCWorkSpaceConfig::dumpConnectionInfoToFile(const boost::filesystem::path& infoFile)
{
  if (_hosts.empty())
  {
    return false;
  }
  
  std::string dest = OSS::boost_path(infoFile);
  std::ofstream destFile(dest.c_str());
  destFile << "# Auto generated by SBCWorkSpaceConfig.  Do not edit this file!" << std::endl;
  destFile << "REDIS_HOST=" << "\"" << _hosts.front().host << "\"" << std::endl;
  destFile << "REDIS_PORT=" << "\"" << _hosts.front().port << "\"" << std::endl;
  destFile << "REDIS_PASS=" << "\"" << _hosts.front().password << "\"" << std::endl;

  return true;
}

bool SBCWorkSpaceConfig::dumpConnectionInfoToFile()
{
  boost::filesystem::path infoFile("/tmp/redis-connect-info");
  return dumpConnectionInfoToFile(infoFile);
}

  
} } } // OSS::SIP::SBC


